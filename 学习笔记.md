# MIT 6.S081

## Lec

### 1

The purposes of an O/S is 

> Abstracting the hardware 	for convenience and portability
>
> Multiplex the hardware between apps
>
> Isolate apps to contain bugs
>
> Allow sharing among cooperating apps
>
> Control sharing for security
>
> Don`t get in the way of high performance
>
> Support a wide range of uses

Organization in a layered pic

>User apps
>
>kernel service
>
>hardware

The typical function that a kernel provide

> Process
>
> memory allocation
>
> file contents
>
> file names, dir
>
> access control
>
> ...

## Lab

### Debugging

```shell
make qemu-gdb # 调试模式开启
#另一窗口
gdb-multiarch
file user/_ls # 读取ls符号表
b main # 在main打断点
c # 让qemu开始运行，可切换到其页面
```

### 1 util

```c
// user/grep.c
int match(char*, char*);

void grep(char *pattern, int fd){
  int n, m;char *p, *q;
  m = 0;
  // 反复读取匹配直到文件结尾或者缓冲区满
  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
    m += n; buf[m] = '\0'; // 更新缓冲区数量,打上结束符
    p = buf;
    while((q = strchr(p, '\n')) != 0){
      *q = 0;
      if(match(pattern, p)){
        *q = '\n';
        write(1, p, q+1 - p);
      }
      p = q+1;
    }
    if(m > 0){
      m -= p - buf;
      memmove(buf, p, m);
    }}}
//
    
int matchhere(char*, char*);int matchstar(int, char*, char*);

int match(char *re, char *text){
  if(re[0] == '^') // 匹配字符串开始
    return matchhere(re+1, text);
  do{  // must look at empty string
    if(matchhere(re, text))
      return 1;
  }while(*text++ != '\0');
  return 0;
}

// matchhere: search for re at beginning of text
int matchhere(char *re, char *text){
  if(re[0] == '\0')
    return 1;
  if(re[1] == '*')
    return matchstar(re[0], re+2, text);
  if(re[0] == '$' && re[1] == '\0')
    return *text == '\0';
  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
    return matchhere(re+1, text+1);
  return 0;
}

// matchstar: search for c*re at beginning of text
int matchstar(int c, char *re, char *text){
  do{  // a * matches zero or more instances
    if(matchhere(re, text))
      return 1;
  }while(*text!='\0' && (*text++==c || c=='.'));
  return 0;
}

// user/ulib.c
// 在字符串中查找字符
char * strchr (const char *s, char c){
    for(; *s; s++) 
        if (*s == c)
            return (char *)s;
    return 0;
}
```

#### sleep(easy)

```c
uint64 sys_sleep(void){
  int n;
  uint ticks0;
  // 获取32位系统调用的参数并赋给n
  if(argint(0, &n) < 0) return -1;
  acquire(&tickslock); // 获取锁(互斥锁)
  ticks0 = ticks; // 记录当前tick
  while(ticks - ticks0 < n){
    if(myproc()->killed){ // 若该程序被kill,则释放并报错
      release(&tickslock);
      return -1;
    }
    sleep(&ticks, &tickslock); // 休眠
  }
  release(&tickslock); // 释放时间锁
  return 0;
}

// kernel/spinlock.h
// 互斥所Mutual exclusion lock.
struct spinlock {
  uint locked;       // Is the lock held?
  // For debugging:
  char *name;        // Name of lock.
  struct cpu *cpu;   // The cpu holding the lock.
};
void acquire(struct spinlock *lk); // 获取锁(循环到达成)
void release(struct spinlock *lk); // 释放锁(若无锁则报错)
void holding(struct spinlock *lk)； // 检查CPU是否持有锁
```

```c
// user/sleep.c
检测输入
调用sleep
退出程序
```

#### Ping Pong (easy)

​	使用read write从pipe中读写

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#define FMT_PING "<%d>:received ping\n"
#define FMT_PONG "<%d>:received pong\n"
#define R 0
#define W 1
int main(int argc, int * argv[]){
    int p[2][2];
    pipe(p[0]); // p -> c
    pipe(p[1]); // c -> p
    char buf[2] = "x\0";
    if(fork() == 0){
        close(p[0][W]);
        close(p[1][R]);
        if(read(p[0][R], buf, 1) > 0){
            printf(FMT_PING, getpid());
            write(p[1][W], buf, 1);
        }else{
            exit(-1);
        }
    }else{
        close(p[0][R]);
        close(p[1][W]);
        write(p[0][W], buf, 1);
        if(read(p[1][R], buf, 1) > 0) {
            printf(FMT_PONG, getpid());
        }else{
            exit(-1);
        }
    }
    exit(0);
}
```



#### Prime(moderate/hard)

​	每个进程只输出接收的第一个数字,并对其倍数进行消除,未被消除的数字(32-byte int)会通过pipe传递到下一个进程.使用goto可以在保持简洁性的情况下避免使用嵌套调用从而时fork不产生不必要的内存复制.

```c
#define REDIR_2_IN(x) close(0), dup(x), close(x);

int main(int argc, char * argv[]){
    uint32 base = 2, cur, flag = 0;
    int p[2];
    pipe(p);
    printf("%d\n", base);
    if(fork() == 0){
        goto sub;
    }else {
        close(p[0]);
        for (uint32 i = 3; i < 35; i += base)
            write(p[1], &i, 4);
        close(p[1]); // close write end of the pipe
        goto end;
    }
sub:
    REDIR_2_IN(p[0]); // re-dir input to the prv pipe
    close(p[1]); // close the prv output
    flag = read(0, &base, 4); // reset the base
    switch (flag) {
        case 0: goto end; break; // one beyond the last one
        case 4: printf("%d\n", base); break;
        default: flag = -1; goto end; break; // failure
    }
    pipe(p);
    if(fork() == 0) // this will cause one redundancy
        goto sub;
    while((flag = read(0, &cur, 4)) == 4){
        if (cur % base != 0)
            write(p[1], &cur, 4);
    }
    close(p[1]); // close write end of the pipe
    if(flag != 0)
        flag = -1;
end:
    wait(0); // waiting for the children to exit
    exit(flag);
}
```

#### find(moderate)

​	阅读ls.c代码不难发现,dir文件实际内容为一条条的**de结构体**.

​	注意strcmp函数是通过第一个判断是否为越界(虽然还有是否相等).注意不要循环进入de.name = '.'和'..'

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/fs.h"
void find(char * path, char * name){
    int fd;
    char buf[512];
    char *p;
    struct dirent de;
    struct stat st;
    if((fd = open(path, 0)) < 0){
        fprintf(2, "ls: cannot open %s\n", path);
        return;
    }
    if(fstat(fd, &st) < 0){
        fprintf(2, "ls: cannot stat %s\n", path);
        close(fd);
        return;
    }
    switch (st.type) {
        case T_FILE:
            for(p = path + strlen(path); p >= path && *p != '/'; p--);
            if(strcmp(++p, name) == 0) {
                printf(path);
                printf("\n");
            }
            break;
        case T_DIR:
            if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
                printf("ls: path too long\n");
                break;
            }
            strcpy(buf, path);
            p = buf + strlen(buf);
            *p++ = '/';
            while(read(fd, &de, sizeof(de)) == sizeof(de)){
                if(de.name[0] != 0 && de.name[0] != '.'){
                    memcpy(p, de.name, DIRSIZ);
                    p[strlen(de.name)] = 0;
                    find(buf, name);
                }
            }
            break;
    }
    close(fd);
}
int main(int argc, char * argv[]){
    if(argc != 3){
        fprintf(2, "usage: find path name\n");
        exit(-1);
    }
    find(argv[1], argv[2]);
    exit(0);
}
```



#### xargs

将前一个的输出传入后一个作为参数,每次读一行作为一个. 

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
int main(int argc, char * argv[]){
    int index, flag;
    uint32 buf_size = 512;
    char buf[buf_size];
    for(int i = 1; i < argc; i++)
        argv[i-1] = argv[i];
    argv[argc-1] = buf;
    while(1){
        for(index = -1; (flag = read(0, buf+1+index, sizeof(char))) > 0 && index+1<buf_size; ){
            if(buf[++index] == '\n') break;
        }
        if(flag == 0){
            if(index > -1)
                buf[index+1] = 0;
            else
                break;
        }else {
            buf[index] = 0;
        }
        if(fork() == 0){
            exec(argv[0], argv);
            exit(0);
        }else{
            wait(0);
        }
    }
    exit(0);
}

```



### 2 Syscalls

#### trace(moderate)

```shell
trace syscallMask cmd
运行cmd中打印掩码对应syscall的信息
调用pid: syscall xxx -> output
......
```

​	使用的掩码定义在kernel/syscall.h中(1<<SYS_xxx)需要修改内核从而调用时打印信息.

```c
// kernel/syscall
// 是一个数组返回一个返回值为uint64参数为void的函数.函数指针为对应返回类型+一个指针
// 使用[]而省略到=是一个已经被废弃但编译器仍然支持的语法
// SYS_xxx定义在syscall.h中,唯一对应的数字
static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
......
[SYS_close]   sys_close,
//等效于SYS_close=sys_close
};

void syscall(void){
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num]();
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```

​	**结构体proc**保存了进程的内核态信息.每个进程有一个私有锁.要实现trace需要添加一个**syscall_mask**变量记录该**进程树**需要追踪的系统调用掩码.

```c
// kernel/proc.h
struct proc {
  struct spinlock lock; // name="proc"
    .......
  // by summage
  uint32 syscall_mask;         // 系统调用掩码
};
// kernel/spinlock.h
struct spinlock {
  uint locked;       // Is the lock held?
  char *name;        // Name of lock.
  struct cpu *cpu;   // The cpu holding the lock.
};
```

​	为此同时还需要**修改fork()函数复制新添加的变量**.

```c
// kernel/proc.c
// Create a new process, copying the parent.
// Sets up child kernel stack to return as if from fork() system call.
int fork(void){
  int i, pid;
  struct proc *np;
  struct proc *p = myproc(); // 获取当前cpu并从中获得当前在运行的程序
  // 分配进程.遍历进程表,先取得进程的私有锁,若已使用则释放锁,否则进行初始化.
  // 初始化需要设置pid(获取pid_lock,pid=nextpid,更新nextpid)并设置状态USED
  // 分配trapframe page, user page table并设置新的上下文
  if((np = allocproc()) == 0){return -1;}
  // 将父进程的用户态数据复制到子进程.
  // 失败则释放子进程分配的内存并将各个状态设置为0(state=UNUSED),并释放锁
  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
    freeproc(np); release(&np->lock); return -1;}
  np->sz = p->sz; // 同步数据大小
  // 复制保存的用户态寄存器
  *(np->trapframe) = *(p->trapframe);
  // 让子进程返回0.(也就是说fork返回a0寄存器的内容)
  np->trapframe->a0 = 0;
  // 复制文件描述符(包括当前所在路径)
  // 给打开的文件描述符的引用数+1
  for(i = 0; i < NOFILE; i++)
    if(p->ofile[i])
      np->ofile[i] = filedup(p->ofile[i]);
  np->cwd = idup(p->cwd);
  
  // 添加以复制mask
  np->syscall_mask = p->syscall_mask;
  
  safestrcpy(np->name, p->name, sizeof(p->name)); // 复制进程名称
  pid = np->pid;
  release(&np->lock); // 释放子进程锁
  // 操作parent属性必须获取wait_lock
  acquire(&wait_lock);
  np->parent = p;
  release(&wait_lock);
  // 设置新进程状态为可运行
  acquire(&np->lock);
  np->state = RUNNABLE;
  release(&np->lock);
  return pid; // 返回子进程pid
}
```

​	**修改syscall,添加打印被追踪函数功能.**(**系统调用名称数组**便于打印)

​	syscall不使用直接传参,而是**使用argxxx(int)从内存栈帧中保存的寄存器处获得**.

```c
#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
// kernel/syscall.h
#define SYS_trace  22
// kernel/syscall.c
#define FMT_TRACE "%d:\t%s\t->\t%d\n"
extern uint64 sys_trace(void);
static char * syscall_name[] = {
         SYS_fork   =   "sys fork",
    ......
         SYS_close  =   "sys close",
         SYS_trace  =   "sys trace",
};
void syscall(void){
  int num; // 被调用的编号
  struct proc *p = myproc();
  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) { // 判断num在数组范围内且对应函数不为空
    p->trapframe->a0 = syscalls[num]();
    if(((1<<num) & p->syscall_mask) != 0){ // 打印被追踪函数
        printf(FMT_TRACE, sys_getpid(), syscall_name[num], p->trapframe->a0);
    }
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
// kernel/sysproc.c
// set trace mask given as the first arg
uint64 sys_trace(void){
    struct proc * p = myproc();
    int mask = 0;
    if(argint(0, &mask) < 0){
        return -1;
    }
    p->syscall_mask = mask;
    return mask;
}
```

##### 用户态函数和内核态函数的接口

由于系统调用一开始对用户空间不可见,所以需要在user.h中加入声明prototype来占位.实际运行时系统调用由usys.pl生成的usys.S来跳转到内核指令.

Run and you will see that the compiler cannot compile `user/trace.c`, because the user-space stubs for the system call don't exist yet: add a prototype for the system call to `user/user.h`, a stub to `user/usys.pl`, and a syscall number to `kernel/syscall.h`. The Makefile invokes the perl script `user/usys.pl`, which produces `user/usys.S`, the actual system call stubs, which use the RISC-V `ecall` instruction to transition to the kernel.

```c
// user/user.h
int trace(int);
// user/usys.pl
entry("trace");
```

#### Sysinfo(moderate)

**添加系统指令sysinfo**, 收集运行中的系统的信息.接受**sysinfo结构体指针**(defined in kernel/sysinfo.h)作为参数.**测试程序 sysinfotest**

```c
// kernel/sysinfo.h
struct sysinfo {
  uint64 freemem;   // amount of free memory (bytes)
  uint64 nproc;     // number of process whose state is not UNUSED
};
```

**常规添加如上**

```c
// kernel/syscall.h
#define SYS_sysinfo 23
// user/user.h
struct sysinfo;
int sysinfo(struct sysinfo *);
// user/usys.pl
entry("sysinfo");
```

**copyout函数示例**

​	只有内核态才有足够的权限接触某些操作,而这不能直接暴露给用户态,需要先在内核态完成记录再使用**copyout(用户态进程的pagetable,需要拷贝到的位置的虚拟内存, 内核态数据源, 字节数)**拷贝到用户态

```c
// kernel/sysfile.c
// argfd 将nth word-sized系统调用参数作为文件描述符并返回描述符和对应文件
// argaddr(syscall.c) 将第n个参数赋给指针所指向对象
// user.h int fstat(int fd, struct stat *st);
uint64 sys_fstat(void){
  struct file *f;
  uint64 st; // user pointer to struct stat
  if(argfd(0, 0, &f) < 0 || argaddr(1, &st) < 0)
    return -1;
  return filestat(f, st);
}
// kernel/fs.c
// 从inode源文件复制stat信息,调用者必须持有ip->lock
void stati(struct inode *ip, struct stat * st){
    st->dev = ip->dev; 
    st->ino = ip->inum;  // 
    st->type = ip->type; st->nlink = ip->nlink; st->size = ip->size;
}
// kernel/file.c
// 获取f的元数据
// addr为用户虚拟地址,指向一个stat
int filestat(struct file *f, uint64 addr){
  struct proc *p = myproc();
  struct stat st;
  if(f->type == FD_INODE || f->type == FD_DEVICE){
    // 带锁情况下复制文件元数据信息
    ilock(f->ip); stati(f->ip, &st); iunlock(f->ip);
    if(copyout(p->pagetable, addr, (char *)&st, sizeof(st)) < 0) return -1;
    return 0;
  }
  return -1;
}
// kernel/vm.c
// 从内核向用户态复制 0成功-1错误
// 复制len字节数据到虚拟地址dstva(物理页地址在pagetable中)
int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len);
// kernel/riscv.h
#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1)) // 找到该内存页起始地址
```

**获取剩余可用内存页**

​	运行时可用内存页由kmem结构体中freelist链表维护,遍历即可.**在defs.h中添加声明**

```c
// kernel/kalloc.c
// Count unused pages in the freelist
// Return number of free bytes
uint64 kcount(void){
    uint64 n = 0;
    acquire(&kmem.lock);
    for(struct run *r = kmem.freelist; r; ++n, r = r->next);
    release(&kmem.lock);
    return n * PGSIZE;
}
```

**获取当前进程数**

​	全局变量进程数组(上限给定了属于是),遍历检查状态即可.**在defs.h中添加声明**

```c
// kernel/proc.c
// Count how many proc are alloced now
uint countproc(void){
    struct proc * p;
    uint count = 0;
    for(p = proc; p < &proc[NPROC]; p++) {
        acquire(&p->lock);
        if (p->state == USED)
            ++count;
        release(&p->lock);
    }
    return count;
}
```

**系统接口**

```c
// return how the number of free mem and used proc now
uint64 sys_sysinfo(void){
    uint64 addr;
    if( argaddr(0, &addr) < 0){return -1;} // 获取用户态信息结构体地址
    // 填充信息
    struct sysinfo info;
    info.freemem = kcount();
    info.nproc = countproc();
    // 内核态到用户态
    struct proc * p = myproc(); 
    if(copyout(p->pagetable, addr, (char *)&info, sizeof(info)) < 0)
        return -1;
    return 0;
}
```

在syscall.h中添加对应条目

### 3 Page table

#### Speed up syscall (easy)

​	通过在内核态和用户态间共用只读内存来加快部分调用.此处需要优化getpid.

> 进程创建时,将一个只读页映射到USYSCALL(memlayout.h). 在这一页的开头保存struct usyscall,并初始化保存该进程pid. ugetpid()被提供给用户态,并会自动调用这个映射.使用pgtbtest测试.

​	**mappages**

```c
// kernel/riscv.h
// 从虚拟地址中抽取3个9位页表索引
#define PXMASK          0x1FF // 9 bits
#define PXSHIFT(level)  (PGSHIFT+(9*(level)))
#define PX(level, va) ((((uint64) (va)) >> PXSHIFT(level)) & PXMASK)
// PTE和PA互换
#define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
#define PTE2PA(pte) (((pte) >> 10) << 12)
// kernel/vm.c
// va 虚拟地址 pa为va对应物理地址
// 为从va开始的虚拟地址创建PTE. va和size不用页对齐.
// 0 成功 -1 walk()没能返回需要的内存页
int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm);
// 返回pagetable中对应va的PTE的地址.如果alloc非0则分配所需的页
pte_t * walk(pagetable_t pagetable, uint64 va, int alloc);
```

**在kernel/proc.c的proc_pagetable中执行映射.**需要修改proc加入struct usyscall* usyscall来记录分配的共享内存页.内存空间从高到低为trampoline, trapframe和共享页USYSCALL.需要在映射,分配和释放(包括freeproc和freepagetable)中加入对应函数.

```c
// kernel/memlayout.h
#define USYSCALL (TRAPFRAME - PGSIZE)
struct usyscall {
  int pid;  // Process ID
};
// kernel/proc.h
struct proc{
  struct usyscall * usycall;  
};
// kernel/proc.c
extern char trampoline[]; // trampoline.S
```

在allocproc中分配这一页面的物理内存,并将pid保存在其中.

```c
static struct proc * allocproc(void){
  // Allocate a trapframe page and a usyscall page.
  if((p->trapframe = (struct trapframe *)kalloc()) == 0 || (p->usyscall = (struct usyscall *)kalloc()) == 0){
    freeproc(p);
    release(&p->lock);
    return 0;
  }
    p->usyscall->pid = p->pid;
}
```

在freeproc中释放这一页面并在二级调用proc_freepagetable中解除映射.

```c
static void freeproc(struct proc *p){
  if(p->usyscall)
    kfree((void*)p->usyscall);
  p->usyscall = 0;
}
// Free a process's page table, and free the
// physical memory it refers to.
void proc_freepagetable(pagetable_t pagetable, uint64 sz){
    uvmunmap(pagetable, USYSCALL, 1, 0);
}
```

将该页映射到trapframe下,并注意设置权限.

```c
// 为进程创建用户页表,没有分配用户内存,但有trampoline pages
pagetable_t proc_pagetable(struct proc *p){
  if(mappages(pagetable, USYSCALL, PGSIZE,
              (uint64)(p->usyscall), PTE_R | PTE_U) < 0){ // 设置只读和对用户可见
      uvmunmap(pagetable, TRAPFRAME, 2, 0);
      uvmfree(pagetable, 0);
      return 0;
  }
}
```

#### print page table(easy)

定义一个名为 `vmprint（）` 的函数。它应该采用`pagetable_t`参数，并以下面描述的格式打印该页表。在 exec.c中插入 `if（p->pid==1） vmprint（p->pagetable），`紧靠`返回 argc` 之前，以打印第一个进程的页表。

```
page table 0x0000000087f6e000
 ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000
 .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000
 .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000
 .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000
 .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000
 ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000
 .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000
 .. .. ..509: pte 0x0000000021fdd813 pa 0x0000000087f76000
 .. .. ..510: pte 0x0000000021fddc07 pa 0x0000000087f77000
 .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000
```

```c
// kernel/vm.c
#define FMT_PGTBL "page table %p\n"
#define FMT_PTE_LEVEL1 " ..%d: pte %p pa %p\n"
#define FMT_PTE_LEVEL2 " .. ..%d: pte %p pa %p\n"
#define FMT_PTE_LEVEL3 " .. .. ..%d: pte %p pa %p\n"
#define FMT_PTE_LEVEL(x) FMT_PTE_LEVEL## x
// print page table
void vm_vmprint(pagetable_t pagetable, int depth){
    char * fmt;
    switch(depth){
        case 1: fmt = FMT_PTE_LEVEL(1); break;
        case 2: fmt = FMT_PTE_LEVEL(2); break;
        case 3: fmt = FMT_PTE_LEVEL(3); break;
        default:
            return;
    }
    for(int i = 0; i < 512; ++i){
        pte_t pte = pagetable[i];
        if(pte & PTE_V){
            printf(fmt, i, pte, PTE2PA(pte));
            if((pte&(PTE_R|PTE_W|PTE_X)) == 0) {
                uint64 child = PTE2PA(pte);
                vm_vmprint((pagetable_t) child, depth + 1);
            }
        }
    }
}

void vmprint(pagetable_t pagetable){
    printf(FMT_PGTBL, pagetable);
    vm_vmprint(pagetable, 1);
}
// kernel/defs.h
void            vmprint(pagetable_t);
```

#### Detecting which pages have been used(hard)

![image-20220531223634877](../pict/MIT6_S081/image-20220531223634877.png) 

![image-20220531223646442](../pict/MIT6_S081/image-20220531223646442.png)

```c
// kernel/syscall.h
#define PTE_A (1L << 6) // 1 -> has been accessed since last clear
```



## XV6 

### Kernel Code

#### entry.S

```assembly
	# qemu -kernel loads the kernel at 0x80000000
        # and causes each CPU to jump there.
        # kernel.ld causes the following code to
        # be placed at 0x80000000.
.section .text
.global _entry
_entry:
	# set up a stack for C.
        # stack0 is declared in start.c,
        # with a 4096-byte stack per CPU.
        # sp = stack0 + (hartid * 4096)
        la sp, stack0
        li a0, 1024*4
	csrr a1, mhartid
        addi a1, a1, 1
        mul a0, a0, a1
        add sp, sp, a0
	# jump to start() in start.c
        call start
spin:
        j spin
```

#### main.c

```c
#include "types.h"
#include "param.h"
#include "memlayout.h"
#include "riscv.h"
#include "defs.h"
volatile static int started = 0;
// start() jumps here in supervisor mode on all CPUs.
void main(){
  if(cpuid() == 0){
    consoleinit();
    printfinit();
    printf("\n");
    printf("xv6 kernel is booting\n");
    printf("\n");
    kinit();         // 物理内存页分配器(将物理内存分页初始化并用链表维护)
    kvminit();       // 创建内核页表
    kvminithart();   // 使能分页
    procinit();      // 进程表
    trapinit();      // 中断向量
    trapinithart();  // install kernel trap vector
    plicinit();      // set up interrupt controller
    plicinithart();  // ask PLIC for device interrupts
    binit();         // buffer cache
    iinit();         // inode table
    fileinit();      // file table
    virtio_disk_init(); // emulated hard disk
    userinit();      // first user process
    __sync_synchronize();
    started = 1;
  } else {
    while(started == 0);
    __sync_synchronize();
    printf("hart %d starting\n", cpuid());
    kvminithart();    // turn on paging
    trapinithart();   // install kernel trap vector
    plicinithart();   // ask PLIC for device interrupts
  }

  scheduler();        
}
```



#### riscv.h

```c
// kernel/riscv.h
// 从虚拟地址中抽取3个9位页表索引
// A 64-bit virtual address is split into five fields:
//   39..63 -- must be zero.
//   30..38 -- 9 bits of level-2 index.
//   21..29 -- 9 bits of level-1 index.
//   12..20 -- 9 bits of level-0 index.
//    0..11 -- 12 bits of byte offset within the page.
#define PXMASK          0x1FF // 9 bits
#define PXSHIFT(level)  (PGSHIFT+(9*(level)))
#define PX(level, va) ((((uint64) (va)) >> PXSHIFT(level)) & PXMASK)
// PTE和PA互换
#define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
#define PTE2PA(pte) (((pte) >> 10) << 12)

// ~(PGSIZE-1)可以获得以PGSIZE对齐的掩码,比如PGSIZE为4096,第13位为1,则该掩码从第13位开始往高位全1,低位为0
#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1)) //sz | page-align即获得sz处或sz后第一个内存页的起始地址
#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1)) // page-align | sz获得sz处或之前的地一个内存页起始地址
```

#### memlayout.h

```c
// Physical memory layout
// qemu -machine virt is set up like this,
// based on qemu's hw/riscv/virt.c:
// 00001000 -- boot ROM, provided by qemu
// 02000000 -- CLINT
// 0C000000 -- PLIC
// 10000000 -- uart0 
// 10001000 -- virtio disk 
// 80000000 -- boot ROM jumps here in machine mode
//             -kernel loads the kernel here
// unused RAM after 80000000.
// the kernel uses physical memory thus:
// 80000000 -- entry.S, then kernel text and data
// end -- start of kernel page allocation area
// PHYSTOP -- end RAM used by the kernel
// qemu puts UART registers here in physical memory.
#define UART0 0x10000000L
#define UART0_IRQ 10
// virtio mmio interface
#define VIRTIO0 0x10001000
#define VIRTIO0_IRQ 1
#ifdef LAB_NET
#define E1000_IRQ 33
#endif
// core local interruptor (CLINT), which contains the timer.
#define CLINT 0x2000000L
#define CLINT_MTIMECMP(hartid) (CLINT + 0x4000 + 8*(hartid))
#define CLINT_MTIME (CLINT + 0xBFF8) // cycles since boot.
// qemu puts platform-level interrupt controller (PLIC) here.
#define PLIC 0x0c000000L
#define PLIC_PRIORITY (PLIC + 0x0)
#define PLIC_PENDING (PLIC + 0x1000)
#define PLIC_MENABLE(hart) (PLIC + 0x2000 + (hart)*0x100)
#define PLIC_SENABLE(hart) (PLIC + 0x2080 + (hart)*0x100)
#define PLIC_MPRIORITY(hart) (PLIC + 0x200000 + (hart)*0x2000)
#define PLIC_SPRIORITY(hart) (PLIC + 0x201000 + (hart)*0x2000)
#define PLIC_MCLAIM(hart) (PLIC + 0x200004 + (hart)*0x2000)
#define PLIC_SCLAIM(hart) (PLIC + 0x201004 + (hart)*0x2000)
// the kernel expects there to be RAM
// for use by the kernel and user pages
// from physical address 0x80000000 to PHYSTOP.
#define KERNBASE 0x80000000L
#define PHYSTOP (KERNBASE + 128*1024*1024)
// map the trampoline page to the highest address,
// in both user and kernel space.
#define TRAMPOLINE (MAXVA - PGSIZE)
// map kernel stacks beneath the trampoline,
// each surrounded by invalid guard pages.
#define KSTACK(p) (TRAMPOLINE - (p)*2*PGSIZE - 3*PGSIZE)
// User memory layout.
// Address zero first:
//   text
//   original data and bss
//   fixed-size stack
//   expandable heap
//   ...
//   USYSCALL (shared with kernel)
//   TRAPFRAME (p->trapframe, used by the trampoline)
//   TRAMPOLINE (the same page as in the kernel)
#define TRAPFRAME (TRAMPOLINE - PGSIZE)

#ifdef LAB_PGTBL
#define USYSCALL (TRAPFRAME - PGSIZE)
struct usyscall {
  int pid;  // Process ID
};
#endif
```



#### kalloc.c

```c
#include "types.h"
#include "param.h"
#include "memlayout.h"
#include "spinlock.h"
#include "riscv.h"
#include "defs.h"
extern char end[]; // 内核后的首个地址
struct run {struct run*next};
struct {
    struct spinlock lock;
    struct run * freelist;
} kmem; // 物理内存中枢?由锁和空闲内存链表组成
void kinit(){
    initlock(&kmem.lock, "kmem");
    freerange(end, (void*) PHYSTOP);
}
void freerange(void * pa_start, void * pa_end); // 释放范围在start和end之间的内存页
void kfree(void * pa){
	struct run *r;
     if(((uint64)pa % PGSIZE) != 0 || (char *pa) < end || (char *) pa >= PHYSTOP) panic("kfree"); // 若未对齐或超出范围则报错
    memset(pa, 1, PGSIZE); // Fill with junk to catch dangling refs.存疑
    r = (struct run*)pa;
    acquire(&kmem.lock); // 带锁情况下将此页面插入空闲列表中
    r->next = kmem.freelist;
    kmem.freelist = r;
    release(&kmem.lock);
}
void * kalloc(void){
    struct run * r;
    acquire(&kmem.lock);
    r = kmem.freelist;
    if(r) kmem.freelist = r->next;
    release(&kmem.lock);
    if(r) memset((char *)r, 5, PGSIZE); 
    return (void*)r;
}
```

​	该文件用于管理**系统运行时的物理内存**.初始化时将所有内存页(内核后到物理边界)填充1并以**struct run 链表维护在kmem的freelist中**.操作涉及freelist时需要取得锁.

#### proc.h

```c
// Saved registers for kernel context switches.
struct context {
  uint64 ra;
  uint64 sp;
  // callee-saved 调用者保存的寄存器(全是s)
  uint64 s0;
......
  uint64 s11;
};

// Per-CPU state.
struct cpu {
  struct proc *proc;          // The process running on this cpu, or null.
  struct context context;     // swtch() here to enter scheduler().
  int noff;                   // Depth of push_off() nesting.
  int intena;                 // Were interrupts enabled before push_off()?
};

extern struct cpu cpus[NCPU];

// per-process data for the trap handling code in trampoline.S.
// 单独占一页,该页就在用户内存页表的trampoline页之后,并没有特别映射到内核页表
// sits in a page by itself just under the trampoline page in the
// user page table. not specially mapped in the kernel page table.
// the sscratch register points here.
// uservec in trampoline.S 将用户寄存器保存在trapframe中
// then initializes registers from the trapframe's
// kernel_sp, kernel_hartid, kernel_satp, and jumps to kernel_trap.
// usertrapret() and userret in trampoline.S set up
// the trapframe's kernel_*, restore user registers from the
// trapframe, switch to the user page table, and enter user space.
// the trapframe includes callee-saved user registers like s0-s11 because the
// return-to-user path via usertrapret() doesn't return through
// the entire kernel call stack.
struct trapframe {
  /*   0 */ uint64 kernel_satp;   // kernel page table
  /*   8 */ uint64 kernel_sp;     // top of process's kernel stack
  /*  16 */ uint64 kernel_trap;   // usertrap()
  /*  24 */ uint64 epc;           // saved user program counter
  /*  32 */ uint64 kernel_hartid; // saved kernel tp
  /*  40 */ uint64 ra;
    .......
  /* 280 */ uint64 t6;
};

enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };

// Per-process state
// 保存进程的基本状态
struct proc {
  struct spinlock lock;
  // p->lock must be held when using these:
  enum procstate state;        // Process state
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID
  // wait_lock must be held when using this:
  struct proc *parent;         // Parent process
  // these are private to the process, so p->lock need not be held.
  uint64 kstack;               // Virtual address of kernel stack
  uint64 sz;                   // Size of process memory (bytes)
  pagetable_t pagetable;       // User page table
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)
  // by summage
  uint32 syscall_mask;         // used by trace to define which syscall to be printed
};

```

#### proc.c

```c
// kernel/proc.c
extern char trampoline[]; // trampoline.S
// 为进程创建用户页表,没有分配用户内存,但有trampoline pages
pagetable_t proc_pagetable(struct proc *p){
  pagetable_t pagetable;
  pagetable = uvmcreate();// An empty page table.
  if(pagetable == 0) return 0;
  // 将trampoline代码映射到最高的用户虚拟地址,仅限监视态在切换内核用户态时使用
  // #define TRAMPOLINE (MAXVA-PGSIZE)
  if(mappages(pagetable, TRAMPOLINE, PGSIZE, (uint64)trampoline, PTE_R | PTE_X) < 0){
    uvmfree(pagetable, 0); return 0;}
  // map the trapframe just below TRAMPOLINE, for trampoline.S.
  if(mappages(pagetable, TRAPFRAME, PGSIZE,
              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
    uvmunmap(pagetable, TRAMPOLINE, 1, 0); // 从va开始解除n个页映射
    uvmfree(pagetable, 0);
    return 0;
  }
  return pagetable;
}
```

#### vm.c

```c
// va 虚拟地址 pa为va对应物理地址
// 为从va开始的虚拟地址创建PTE. va和size不用页对齐.
// 0 成功 -1 walk()没能返回需要的内存页
// perm为页属性
int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm){
  uint64 a, last;
  pte_t *pte;
  if(size == 0) panic("mappages: size");
  a = PGROUNDDOWN(va);
  last = PGROUNDDOWN(va + size - 1);
  for(;;){
      // 分配失败
    if((pte = walk(pagetable, a, 1)) == 0) return -1;
    // 返回的页表项仍可以向下索引
    if(*pte & PTE_V) panic("mappages: remap");
    *pte = PA2PTE(pa) | perm | PTE_V;
    if(a == last) break;
    a += PGSIZE;
    pa += PGSIZE;
  }
  return 0;
}
// 返回pagetable中对应va的PTE的地址.如果alloc非0则分配所需的页
pte_t * walk(pagetable_t pagetable, uint64 va, int alloc){
  if(va >= MAXVA) panic("walk");
    // 逐级对pagetable进行索引
  for(int level = 2; level > 0; level--) {
    pte_t *pte = &pagetable[PX(level, va)];
    if(*pte & PTE_V) {//1L << 0 有效,即仍可以向下索引
      pagetable = (pagetable_t)PTE2PA(*pte);
    } else {
        // 如果不需要分配或分配失败则返回0
      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0) return 0;
      // 初始化分配的页并初始化对应PTE
      memset(pagetable, 0, PGSIZE);
      *pte = PA2PTE(pagetable) | PTE_V;
    }
  }
  return &pagetable[PX(0, va)];
}

// 从内核向用户态复制 0成功-1错误
// 复制len字节数据到虚拟地址dstva(物理页地址在pagetable中)
int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len){
  uint64 n, va0, pa0;
  while(len > 0){
    va0 = PGROUNDDOWN(dstva); // 找到该内存页起始地址
    pa0 = walkaddr(pagetable, va0); // 找到虚拟地址对应物理地址(0若未分配not mapped)只能用于查找用户内存页
    if(pa0 == 0) return -1; // 未分配报错
    n = PGSIZE - (dstva - va0); // 目的地址剩余可用内存
    if(n > len) n = len; // 复制min(n, len)字节
    memmove((void *)(pa0 + (dstva - va0)), src, n);
    len -= n; src += n; dstva = va0 + PGSIZE;//切换到下一页
  }
  return 0;
}
```

#### stat.h

```c
#define T_DIR     1   // Directory
#define T_FILE    2   // File
#define T_DEVICE  3   // Device
struct stat {
  int dev;     // File system's disk device
  uint ino;    // Inode number
  short type;  // Type of file
  short nlink; // Number of links to file
  uint64 size; // Size of file in bytes
};
```

#### fs.h

````c
// kernel/fs.h
#define DIRSIZE 14 // 最短长度,不足使用空格填充
struct dirent {
  ushort inum;
  char name[DIRSIZ];
};
````

### User Code

#### initcode.S

```assembly
# Initial process that execs /init.
# This code runs in user space.
#include "syscall.h"
# exec(init, argv)
.globl start
start:
        la a0, init # 装载被执行函数地址
        la a1, argv # 装载参数
        li a7, SYS_exec # 装载要调用的系统调用
        ecall # 进入内核态执行exec
# for(;;) exit();
exit:
        li a7, SYS_exit
        ecall
        jal exit
# char init[] = "/init\0";
init:
  .string "/init\0"
# char *argv[] = { init, 0 };
.p2align 2
argv:
  .long init
  .long 0
```

#### init.c

```c
// init: The initial user-level program
char *argv[] = { "sh", 0 };
int main(void){
  int pid, wpid;
  // 打开0,1,2描述符
  if(open("console", O_RDWR) < 0){
    mknod("console", CONSOLE, 0);
    open("console", O_RDWR);
  }
  dup(0);  // stdout
  dup(0);  // stderr
  for(;;){
    printf("init: starting sh\n");
    pid = fork();
    if(pid < 0){
      printf("init: fork failed\n");
      exit(1);
    }
    if(pid == 0){
      exec("sh", argv);
      // 若成功会更新当前空间为"sh"中指令,否则则失败
      printf("init: exec sh failed\n");
      exit(1);
    }
    for(;;){
      // this call to wait() returns if the shell exits,
      // or if a parentless process exits.
      wpid = wait((int *) 0);
      if(wpid == pid){
        // the shell exited; restart it.
        break;
      } else if(wpid < 0){
        printf("init: wait returned an error\n");
        exit(1);
      } else {
        // it was a parentless process; do nothing.
      }}}}
```

#### ls.c

```c
char* fmtname(char *path){
  static char buf[DIRSIZ+1];
  char *p;
  // 找到反斜杠后第一个字符位置
  for(p=path+strlen(path); p >= path && *p != '/'; p--);
  p++;
  // 返回空格填充后的名称
  if(strlen(p) >= DIRSIZ) return p;
  memmove(buf, p, strlen(p)); memset(buf+strlen(p), ' ', DIRSIZ-strlen(p)); return buf;
}
void ls(char *path){
  char buf[512], *p; int fd; struct dirent de;struct stat st;
  if((fd = open(path, 0)) < 0){....} if(fstat(fd, &st) < 0){....} // 错误处理
  switch(st.type){
  case T_FILE: printf("%s %d %d %l\n", fmtname(path), st.type, st.ino, st.size); break;
  case T_DIR:
    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
      printf("ls: path too long\n");break;}
    // 将路径复制到buf并添加反斜杠
    strcpy(buf, path); p = buf+strlen(buf); *p++ = '/';
    while(read(fd, &de, sizeof(de)) == sizeof(de)){
      // 存疑
      if(de.inum == 0) continue;
      // 生成路径
      memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0;
      if(stat(buf, &st) < 0){ // 只读方式打开并读取状态
        ....}
      printf("%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
    }
    break;
  }
  close(fd);
}
```



### Chap 1

​	进程通过系统调用invokes a system call获得**系统服务**，进入内核态完成操作并返回。内核通过硬件提供的保护机制保证进程只能操作自己的存储。内核态exec with **the hardware privileges** required to implement these protections 而用户态没有这个权限。在调用系统服务时，硬件会**提高其权限等级并执行pre-aranged内核函数**。Shell是用户程序而非内核的一部分。

#### Processes and memory

​	一个xv6进程有用户态内存和内核私有的pre-process state。

> XV6 time-shares process
>
> 将可用CPU在等待执行的进程间透明切换transparently switches among...并保存未在执行进程的寄存器。
>
> 内核为每个进程分配一个PID作为识别符号。

![image-20220529094246634](../pict/MIT6_S081/image-20220529094246634.png)

> 进程可以通过**fork()**系统调用创建子进程，会**完整复制**父进程的所有内存空间**(copy-on-write优化)**。**父子进程之间不共享内存,互不影响**.该调用在父子进程分别返回**子进程PID**和0，**失败**返回-1。 
>
> **exit(int)**会终止调用进程并释放内存,文件等资源.
>
> **wait(iint \* status)**返回一个exited or killed的子进程(若无则等待)的PID并将其退出状态复制到给定地址**(地址0即抛弃状态)**,*无子进程*时返回-1.
>
> **exec(char \* file, char \* argv[])** 将当前进程的内存替换为从特定格式文件(XV6为ELF)中读取的内存映像memory image但不会改变内核态和文件描述符表,之后并不返回调用程序,而是从**读取的指令中指定的位置开始执行.** *(文件必须明确指令,数据的位置以及从哪条指令开始)* 一般情况,argv[0]会被忽略(所以一般为被调用程序名).
>
> ```c
> // shell
> // user/sh.c 145
> // fork and exec are not combined in a single call
> // 这样子进程先与父进程使用虚拟内存技术先不复制,而后直接使用exec获得新内容从而避免生成重复进程而后马上抛弃
> // 这一seperation被用于shell IO重定向的实现中
> int main(void){
>     static char buf[100];
>     int fd;
>     // Ensure the three file descriptors are open
>     while((fd = open("console", O_RDWR) >= 0)){
>         if (fd > 3){
>             close(fd);
>             break;
>         }
>     }
>     // Read and run the input commands
>     while (getcmd(buf, sizeof(buf)) >= 0){
>         if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
>             // Chdir must be called by the parent, not the child
>             buf[strlen(buf)-1]=0; // chop \n
>             if(chdir(buf+3) < 3)
>                 fprintf(2, "cannot cd %s\n", buf+3);
>             continue;
>         }
>         if(fork1() == 0) // Run other command by the child
>             runcmd(parsecmd(buf));
>         wait(0);
>     }
>     exit(0);
> }
> ```
>
> ​	xv6一般隐式分配内存.fork为子进程分配复制所需空间,exec为保存可执行文件分配空间.或者可以调用**sbrk(n)**来增加n字节内存,其返回值为内存地址.

#### IO and File descriptors

​	**文件描述符**是代表a kernel-managed object的小整数.Internally, the xv65 kernel uses them as **an index into a pre-process table**,从而为每个进程提供从0开始的独立文件描述符空间.*(0 stdin 1 stdout 2 stderr)*. read/write(fd, buf, n) a subsequent one will pick up where the previous one left off. read返回被读取数,0表示文件结束, 负数错误.write返回写入数目,小于n错误.**close**会释放当前文件描述符(**分配为当前可用的最小数字**).

由于fork会复制一切内容,而exec不会更改文件描述符表,所以可以通过二者结合完成**IO redirection**. open接受flag( kernel/fcntl.h) O_RDONLY, O_WRONLY, O_RDWR, O_CREATE, and O_TRUNC.

```c
// cat < input.txt
char * argv[2];
argv[0] = "cat"; argv[1] = 0;
if (fork() == 0){
    // 先关stdin再开,从而保证替换
    close(0);
    open("input.txt", O_RDONLY);
    exec("cat", argv);
}
// user/sh.c 82
  case REDIR:
    rcmd = (struct redircmd*)cmd;
    close(rcmd->fd);
    if(open(rcmd->file, rcmd->mode) < 0){
      fprintf(2, "open %s failed\n", rcmd->file);
      exit(1);
    }
    runcmd(rcmd->cmd);
    break;
//
struct redircmd {
  int type;
  struct cmd *cmd;
  char *file;
  char *efile;
  int mode;
  int fd;
};
```

​	**dup(int fd)**返回新文件描述符(记做文件),但二者指向同一个对象.ls xx > tmp1 2>&1 这条指令将xx下文件输出,且输出重定向为tmp1,而2>&1表示错误输出为输出的dup.

#### Pipes

A small kernel buffer exposed to processes as a pair of file descriptors.

```c
int p[2];
char * argv[2];
argv[0] = "wc";
argv[1] = 0;

pipe(p); // [读端, 写端]
if(fork() == 0){
    close(0);
    dup(p[0]);
    close(p[0]);
    close(p[1]); // 避免接下来执行的程序中有一个描述符指向写端导致读一直阻塞
    exec("/bin/wc", argv);
}else{
    close(p[0]);
    write(p[1], "hello world!\n", 12);
    close(p[1]);
}
```

​	在没有数据时,read会等待写入端写入或关闭,若关闭,则返回0.

​	xv6对pipe会创建**两个子进程**,并可能进一步形成**树形结构**,

```c
  case PIPE:
    pcmd = (struct pipecmd*)cmd;
    if(pipe(p) < 0)
      panic("pipe");
    if(fork1() == 0){
      close(1);
      dup(p[1]);
      close(p[0]);
      close(p[1]);
      runcmd(pcmd->left);
    }
    if(fork1() == 0){
      close(0);
      dup(p[0]);
      close(p[0]);
      close(p[1]);
      runcmd(pcmd->right);
    }
    close(p[0]);
    close(p[1]);
    wait(0);
    wait(0);
    break;
```

#### File system

```c
chdir(char * ); // =cd, 不以/开头则为当前目录开始. 
mknod(char \* file, int MajorNum, int MinorNum); // 创建指代设备的特殊文件
```

When a process open a device file, the kernel diverts read and write syscalls to the kernel device implementation rather than passing them to the file system.一个实际存储的文件**inode holding the metadata**(有唯一的inode number)可以有多个链接**links**.(A file’s name is distinct from the file itself; the same underlying file, called an inode, can have multiple names, called links)

```c
// kernel/file.h
struct file{
    enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE} type;
    int ref; // reference 计数
    char readable;
    char writable;
    struct pipe * pipe; // FD_PIPE
    struct inode * ip; // FD_INODE and FD_DEVICE
    uint off;		   // FD_INODE
    short major; 		// FD_DEIVCE
}
// fstat系统调用可以返回描述符指向的元数据的信息
// kernel/stat.h
#define T_DIR     1   // Directory
#define T_FILE    2   // File
#define T_DEVICE  3   // Device

struct stat {
  int dev;     // File system's disk device
  uint ino;    // Inode number
  short type;  // Type of file
  short nlink; // Number of links to file
  uint64 size; // Size of file in bytes
};
//
open("a", O_CREATE|OWRONLY);
link("a","b"); // fstat返回数据中ino相同且nlink为2
unlink("a"); // 解除一个链接,但由于nlink仍大于0所以文件仍然保存着.
```

​	由于cd必须改变当前工作路径,所以存在于shell而非文件系统.

### Chap 2

#### Process overview

​	xv6中**隔离的单位为进程**,其抽象**防止进程导致内核崩溃或监听其他进程**.而内核实现其的机制包括**用户/监视者态,地址空间和time-slicing of threads**.为了强化隔离性,进程的抽象会让其认为其占有整个机器.

![image-20220531154721398](../pict/MIT6_S081/image-20220531154721398.png)

​	xv6使用**页表(硬件实现)**来为进程分配空间,将虚拟地址转为物理地址.进程的地址空间包括从虚拟地址0开始的用户内存.(依次为指令,全局变量,桟区,堆区(用于malloc)). RISCV的指针为64位,而页表中内存寻址只用低39位,而xv6只用这之中的38位.所以**MAXVA=2^38^-1=0x3fffffffff(kernel/riscv.h)**.在地址空间的顶端(高地址)为**trampoline和映射进程trapframe的一页**.这两页被用于**内核态和用户态切换**.trampoline包含进出内核的代码,并且在需要保存或回复用户进程状态时映射trapframe.

​	内核为每个进程维护了许多状态,存储在struct proc(kernel/proc.h)中,以page table最为重要.每个进程都有一个**执行线程a thread of execution**,通过暂停suspend一个并恢复另一个,内核完成进程间的透明切换.而线程的大部分状态保存在栈中(**用户栈和内核栈p->kstack**),执行指令时仅使用user stack(**此时内核stack为空**),进入内核态后在kernel stack上运行(**user stack仍保存有数据**).

​	进程通过执行**RISC-V 的 ecall**指令来invoke a system call,这会**提高硬件优先级,并将pc移到内核规定的进入点**.之后切换为kernel stack,并执行内核指令(系统调用).完成后使用**sret**切换回用户态.

#### The first process and syscall

​	上电时系统初始化并运行**boot loader(on read-only mem)**,RISC-V**禁用了内存映射**(一一对应),将内核读入内存0x80000000**(前面一部分内存保存IO设备)**.而后在machine mode,CPU从**\_entry(kernel/entry.S)**开始执行内核.此处的指令会**建立stack0(kernel/start.c)**从而让xv6可以运行c,而后将stack0+4096装入sp,即栈顶. Now that the kernel has a stack, _entry calls into C code at start(kernel/start.c:21).start保持在machine mode完成初始化并**设置时钟芯片产生时间中断**,随后调用mret进入supervision mode. 这会将pc切换到main函数.main**初始化数个设备和子系统并调用userinit创建第一个进程**.The first process  make makes the first system call in xv6. initcode.S (user/initcode.S:3) loads the number for the exec system call, SYS_EXEC (kernel/syscall.h:8), into register a7, and then calls ecall to re-enter the kernel.

The kernel uses the number in register a7 in syscall (kernel/syscall.c:133) to call the desired
system call.一旦完成了exec,便会返回init进程的用户态,进而打开另一个console,并打开0,1,2文件描述符.

#### Security Model

### Chap 3 page tables

#### Paging Hardware

​	由于xv6仅使用虚拟地址的低39位,所以Page Table Entry一般只**使用低54位(高44位为Physical Page Number,低10位为标志)**, 而分页硬件将top27-39位复制作为虚拟地址(用于在PT中查找对应PTE),使用PPN作为高位,12位虚拟地址作为低位生成56位物理地址.

​	三级页表虽然可以大幅减少内存占用,但是需要读取到内存才能完成查找,而为了避免这种情况, RISCV CPU将PTE缓存在Translation Look-aside Buffer中. 
