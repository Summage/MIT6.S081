

/kernel/defs.h
void            ramdiskrw(struct buf*);
void*           kalloc(void);
void            kfree(void *);
void            kinit(void);

int             kref(uint64, char);
char *          cow(pagetable_t pagetable, uint64 va);
// log.c
void            initlog(int, struct superblock*);
void            log_write(struct buf*);

++ b/kernel/kalloc.c
void freerange(void *pa_start, void *pa_end);
extern char end[]; // first address after kernel.
                   // defined by kernel.ld.

#define INDEX(pa) (((uint64)pa-PGROUNDUP((uint64)end))/PGSIZE)

struct run {
  struct run *next;
};
struct run {
struct {
  struct spinlock lock;
  struct run *freelist;
  uint8 page_ref[(PHYSTOP - KERNBASE) / PGSIZE];
} kmem;

void
kinit()
{
  initlock(&kmem.lock, "kmem");
  acquire(&kmem.lock);
  // set all pages` ref count to 1 so that kfree can work properly
  memset(kmem.page_ref, 1, INDEX(PHYSTOP));
  release(&kmem.lock);
  // for(int i = (PHYSTOP - KERNBASE) / PGSIZE; i--; kmem.page_ref[i] = 1);
  freerange(end, (void*)PHYSTOP);
}

kfree(void *pa)
  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
    panic("kfree");

  // Fill with junk to catch dangling refs.
  memset(pa, 1, PGSIZE);

  r = (struct run*)pa;

  acquire(&kmem.lock);
  r->next = kmem.freelist;
  kmem.freelist = r;
  // update page ref count and free the physical page when no ref exits
  switch(kmem.page_ref[INDEX(pa)]){
    case 0:
      panic("kfree: double free");
    case 1:
      r->next = kmem.freelist;
      kmem.freelist = r;
      // Fill with junk to catch dangling refs.
      memset(pa, 1, PGSIZE);
    default:
      --kmem.page_ref[INDEX(pa)];
      break;
  }
  release(&kmem.lock);
}

kalloc(void)

  acquire(&kmem.lock);
  r = kmem.freelist;
  if(r)
  if(r){
    kmem.freelist = r->next;
    kmem.page_ref[INDEX(r)] = 1; // set page ref to 1
  }
  release(&kmem.lock);

  if(r)
    memset((char*)r, 5, PGSIZE); // fill with junk
  return (void*)r;
}

int kref(uint64 pa, char change){ // change: 0 return current ref count; else increment ref count by 1
  int index = (pa - KERNBASE) / PGSIZE;
  if(change != 0){
    acquire(&kmem.lock);
    if(++kmem.page_ref[index] == 1)
      panic("kref: trying to refer to an unalloced page!");
    release(&kmem.lock);
  }

  return kmem.page_ref[index];
}

// alloc a new page(writable) and copy the content into it
// deref the origional physical page
// return the newly alloced physical page
char * cow(pagetable_t pagetable, uint64 va){
  char * mem = kalloc();
  if(mem == 0){
    printf("cow:failed to alloc required page\n");
    return 0;
  }
  pte_t * pte = walk(pagetable, va, 0);
  memmove(mem, (void*)PGROUNDDOWN(PTE2PA(*pte)), PGSIZE);
  kfree((void*)PTE2PA(*pte));
  *pte = PA2PTE(mem) | ((PTE_FLAGS(*pte) | PTE_W) & ~PTE_C);
  return mem; 



typedef uint64 *pagetable_t; // 512 PTEs
#define PTE_W (1L << 2)
#define PTE_X (1L << 3)
#define PTE_U (1L << 4) // user can access
#define PTE_C (1L << 7) // COW page

// shift a physical address to the right place for a PTE.
#define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)

//kernel/trap.c
usertrap(void)
    syscall();
  } else if((which_dev = devintr()) != 0){
    // ok
  } else {
  } else if(r_scause() == 15){ // Write storage error
    uint64 va = PGROUNDDOWN(r_stval());
    struct proc * p = myproc();
    if(va >= MAXVA || va >= p->sz){
      printf("usertrap(): writing out of boundary scause %p pid=%d\n", r_scause(), p->pid);
      printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
      setkilled(p);
      goto usertrap_kill;
    }
    pte_t * pte = walk(p->pagetable, va, 0);
    if(pte == 0 || (*pte & PTE_V) == 0 || (*pte & PTE_C) == 0 || (*pte & PTE_U) == 0){
      printf("usertrap(): writing to an invalid va scause %p pid=%d\n", r_scause(), p->pid);
      printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
      setkilled(p);
      goto usertrap_kill;
    }
    if(kref(PTE2PA(*pte), 0) == 1){ // now the page is only refed by the current proc
      *pte = (*pte | PTE_W) & ~PTE_C;
    }else{ // alloc and copy is needed
      if(cow(p->pagetable, va) == 0){
        printf("usertrap(): failed to alloc required page scause %p pid=%d\n", r_scause(), p->pid);
        printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
        setkilled(p);
        goto usertrap_kill;
      }
    }
  }else {
    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
    setkilled(p);
  }

usertrap_kill:
  if(killed(p))
    exit(-1);


b/kernel/vm.c

uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
  pte_t *pte;
  uint64 pa, i;
  uint flags;
  char *mem;
  uint64 mem;

  for(i = 0; i < sz; i += PGSIZE){
    if((pte = walk(old, i, 0)) == 0)

vmcopy(pagetable_t old, pagetable_t new, uint64 sz)
    if((*pte & PTE_V) == 0)
      panic("uvmcopy: page not present");
    pa = PTE2PA(*pte);
    flags = PTE_FLAGS(*pte);
    if((mem = kalloc()) == 0)
      goto err;
    memmove(mem, (char*)pa, PGSIZE);
    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
      kfree(mem);
    *pte = (*pte & ~PTE_W) | PTE_C; // both parent and child page should be dis-writable and be marked as COW
    flags = PTE_FLAGS(*pte); 
    kref(pa, 1); // add a ref to the target physical page
    mem = PTE2PA(*pte);
    if(mappages(new, i, PGSIZE, mem, flags) != 0){
      kfree((void*)mem);
      goto err;
    }
  }
copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
    pa0 = walkaddr(pagetable, va0);
    if(pa0 == 0)
      return -1;
    if(kref(pa0, 0) > 1){
      if((pa0 = (uint64)cow(pagetable, va0)) == 0)
        panic("copyout: failed to exec cow!");
    }
    n = PGSIZE - (dstva - va0);
    if(n > len)
      n = len;
